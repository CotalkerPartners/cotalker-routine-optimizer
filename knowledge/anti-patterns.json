{
  "patterns": [
    {
      "id": "LOOP_WITH_NETWORK_CALLS",
      "severity": "CRITICAL",
      "detect": {
        "stageType": "FCEach",
        "hasChildType": "NWRequest"
      },
      "message": "FCEach loop contains network requests (N+1 query pattern)",
      "recommendation": "Convert to batch operation using /multi endpoint or consolidated CCJS",
      "reference": "trigger_formulario_optimized.js:1227",
      "exampleFix": {
        "description": "Replace FCEach iteration with batch query",
        "before": "FCEach → NWRequest per iteration",
        "after": "CCJS (prepare query) → Single NWRequest (batch) → CCJS (consolidate)"
      }
    },
    {
      "id": "FULL_ARRAY_PATCH",
      "severity": "HIGH",
      "detect": {
        "stageType": "NWRequest",
        "bodyContains": {
          "op": "add",
          "pathPattern": "^/[^/]+$"
        },
        "estimatedPayloadSize": ">1MB"
      },
      "message": "Full array replacement detected with large payload (should use incremental patches)",
      "recommendation": "Add CCJS delta computation, use path '/-' for append operations. See trade-offs.md for when full replacement is acceptable.",
      "reference": "trigger_formulario_optimized.js:134",
      "exampleFix": {
        "description": "Use incremental JSON Patch instead of full replacement",
        "before": "{ op: 'add', path: '/field', value: [entire array] }",
        "after": "delta.forEach(id => jsonPatch.push({ op: 'add', path: '/field/-', value: id }))"
      },
      "canSuppress": true,
      "suppressComment": "full-array-patch-justified: initial sync operation"
    },
    {
      "id": "MISSING_ERROR_ROUTING",
      "severity": "MEDIUM",
      "detect": {
        "stageType": ["NWRequest", "PBScript"],
        "next": {
          "ERROR": ""
        }
      },
      "message": "Critical stage missing error handler",
      "recommendation": "Add global error handler stage and route ERROR → send_error_message",
      "reference": "trigger_formulario_optimized.js:1642",
      "exampleFix": {
        "description": "Add error routing to critical stages",
        "before": "next: { SUCCESS: 'next_stage', ERROR: '' }",
        "after": "next: { SUCCESS: 'next_stage', ERROR: 'send_error_message' }"
      }
    },
    {
      "id": "NO_BYPASS_SWITCH",
      "severity": "LOW",
      "detect": {
        "stageType": "FCEach",
        "controlFromOutput": true,
        "noUpstreamCheck": true,
        "estimatedEmptyFrequency": ">30%"
      },
      "message": "Loop frequently runs with empty data (consider adding bypass switch)",
      "recommendation": "Add FCSwitchOne check with hasItems boolean from CCJS. Cost effective when loop body is expensive or empty cases are frequent (>30%). See trade-offs.md.",
      "reference": "trigger_formulario_optimized.js:1372",
      "exampleFix": {
        "description": "Add conditional check before loop",
        "before": "CCJS → FCEach (runs even if empty)",
        "after": "CCJS (returns hasItems) → FCSwitchOne → FCEach (only if hasItems=true)"
      },
      "canSuppress": true,
      "suppressComment": "bypass-switch-not-needed: loop body is trivial / empty case is rare"
    },
    {
      "id": "COTLANG_WRONG_DELIMITER",
      "severity": "HIGH",
      "detect": {
        "expressionPattern": "\\$VALUE#[^#]+#[^#]+(?<!\\$[A-Z]+#[^#]+#[^#]+)"
      },
      "message": "Incorrect COTLang delimiter (using # for object navigation instead of |)",
      "recommendation": "Use | for object keys, # for command arguments",
      "reference": "cotlang-reference.md",
      "exampleFix": {
        "description": "Fix delimiter usage in COTLang expression",
        "before": "$VALUE#sentAnswer#data#process",
        "after": "$VALUE#sentAnswer|data|process"
      }
    },
    {
      "id": "LARGE_PAYLOAD_WITHOUT_DELTA",
      "severity": "HIGH",
      "detect": {
        "stageType": "CCJS",
        "followedBy": "NWRequest",
        "estimatedPayloadSize": ">1MB",
        "hasPreviousVersion": true,
        "sendingFullDataset": true
      },
      "message": "CCJS stage sending large payload (>1MB) without delta computation",
      "recommendation": "Compute delta between current and new state. Implementation can use Set, Map, diff algorithms, or other strategies. See trade-offs.md for guidance.",
      "reference": "trigger_formulario_optimized.js:134",
      "exampleFix": {
        "description": "Compute delta before sending (example using Set)",
        "before": "return { allItems: incoming };",
        "after": "const currentSet = new Set(current); const delta = incoming.filter(id => !currentSet.has(id)); return { delta };"
      },
      "alternativeImplementations": [
        "Set-based filtering (recommended for simple ID arrays)",
        "Map-based for complex object comparison",
        "fast-diff library for large datasets",
        "Immutable.js with structural sharing",
        "Custom diff algorithm for domain-specific needs"
      ],
      "canSuppress": true,
      "suppressComment": "delta-not-needed: first initialization / reset operation"
    },
    {
      "id": "UNSAFE_JSON_PARSING",
      "severity": "MEDIUM",
      "detect": {
        "stageType": "CCJS",
        "srcContains": "JSON.parse",
        "missingPattern": "try.*catch",
        "noSchemaValidation": true
      },
      "message": "JSON.parse without error handling (will crash on malformed data)",
      "recommendation": "Use safeJSON helper function or schema validation library",
      "reference": "trigger_formulario_optimized.js:549",
      "exampleFix": {
        "description": "Add safe JSON parsing",
        "before": "const data = JSON.parse(input);",
        "after": "const safeJSON = (val, def) => { if (val == null) return def; try { return JSON.parse(val.trim()); } catch { return def; } }; const data = safeJSON(input, {});"
      },
      "alternativeImplementations": [
        "safeJSON helper function (recommended for CCJS)",
        "Zod schema validation with .parse()",
        "Yup validation",
        "io-ts runtime type checking"
      ],
      "canSuppress": true,
      "suppressComment": "json-parsing-safe: validated by schema / TypeScript types / upstream validation"
    },
    {
      "id": "INEFFICIENT_MEMBERSHIP_TEST",
      "severity": "LOW",
      "detect": {
        "stageType": "CCJS",
        "srcContains": ".filter(.*\\.includes\\(",
        "estimatedArraySize": ">100"
      },
      "message": "Using array.includes() in filter with large arrays (O(n²) complexity)",
      "recommendation": "Convert to Set for O(1) membership testing when array size >100",
      "reference": "trigger_formulario_optimized.js:134",
      "exampleFix": {
        "description": "Replace includes with Set.has for better performance",
        "before": "items.filter(id => existing.includes(id))",
        "after": "const existingSet = new Set(existing); items.filter(id => existingSet.has(id))"
      },
      "performanceImpact": {
        "small": "Negligible for arrays <100 elements",
        "medium": "Noticeable for arrays 100-1000 elements",
        "large": "Critical for arrays >1000 elements"
      }
    },
    {
      "id": "NESTED_FCEACH_LOOPS",
      "severity": "CRITICAL",
      "detect": {
        "stageType": "FCEach",
        "hasDescendantType": "FCEach"
      },
      "message": "Nested FCEach loops (O(n²) complexity, potential timeout)",
      "recommendation": "Flatten loops using CCJS preprocessing",
      "reference": "optimization-patterns.md",
      "exampleFix": {
        "description": "Eliminate nested loops",
        "before": "FCEach (outer) → FCEach (inner) → NWRequest",
        "after": "CCJS (flatten data) → Single batch operation"
      }
    },
    {
      "id": "MISSING_ARRAY_VALIDATION",
      "severity": "LOW",
      "detect": {
        "stageType": "CCJS",
        "srcContains": "data\\.[a-zA-Z]+\\.(map|filter|forEach)",
        "missingPattern": "Array\\.isArray",
        "noTypeSystem": true
      },
      "message": "Array method called without checking if value is array",
      "recommendation": "Add Array.isArray() check before array operations, or use TypeScript/schema validation",
      "reference": "trigger_formulario_optimized.js:134",
      "exampleFix": {
        "description": "Add array validation",
        "before": "const result = data.items.map(x => x.id);",
        "after": "const items = Array.isArray(data.items) ? data.items : []; const result = items.map(x => x.id);"
      },
      "canSuppress": true,
      "suppressComment": "array-validation-not-needed: TypeScript types enforce / schema validation present / upstream guarantees type"
    },
    {
      "id": "EXCESSIVE_LOOP_ITERATIONS",
      "severity": "HIGH",
      "detect": {
        "stageType": "FCEach",
        "estimatedIterations": ">1000",
        "bodyContainsNetworkCall": true
      },
      "message": "Loop with excessive iterations and network calls (potential timeout)",
      "recommendation": "Consider batch operations, pagination, or async processing for >1000 iterations with network I/O",
      "reference": "trade-offs.md",
      "exampleFix": {
        "description": "Use batch operations instead of individual requests",
        "before": "FCEach (1000+ iterations) → NWRequest",
        "after": "CCJS (chunk into batches of 100) → FCEach (10 batches) → NWRequest (/multi endpoint)"
      },
      "thresholds": {
        "warning": 500,
        "error": 1000,
        "critical": 5000
      },
      "reasoning": "Based on Lambda timeout (15min max) and average network call time (250ms), not arbitrary limits"
    }
  ],
  "metadata": {
    "version": "2.0.0",
    "lastUpdated": "2026-01-16",
    "philosophy": "Detect problematic behaviors, not specific implementations. Allow suppression with justification. Consider context and trade-offs."
  }
}
